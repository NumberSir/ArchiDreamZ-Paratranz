***Paratranz格式双向转换项目：
我正在进行一个翻译项目，将我的世界的模组语言文件、游戏信函文本、NPC对话文本等上传到Paratranz云翻译平台来翻译。
但是Paratranz平台的文件上传有格式要求，必须是用.json或.csv做成键值对格式才能够被平台识别。因此我需要你写一个提取-还原程序，能将各类游戏文件中的待翻译文本提取出来，并转换为键值对的.json格式的py程序，并且在我翻译完之后，能够将键值对.json还原回原文件的格式。
在编写代码时，需要模块化处理不同的文件类型，使用函数来封装每种处理逻辑，并在开头写一个根据文件类型选择不同的处理逻辑函数的主函数。
该程序必须做到写出详细的注释以提升代码可读性。

***该项目有如下文件结构：
Code（存放该程序的py代码）
1-SourceFile（存放的是游戏文件的原文件，可直接被游戏读取。）
2-ConvertedParatranzFile（存放的是经过程序提取出来的，待上传Paratranz网站的文件。）
3-TranslatedParatranzFile（存放的是从Paratranz翻译完下载下来的待还原格式文件）
4-SourceTranslatedFile（存放的是还原回原格式的文件）
运行.bat（双击运行程序，通过输入123来选择是运行提取还是还原）


***简要工作流程概述：
我会把游戏文本的原文件放进“1-SourceFile”文件夹中，你检测该文件夹所有文件，执行提取程序，然后将提取好的文件输出到“2-ConvertedParatranzFile”文件夹中，我会将这些文件上传至Paratranz。在Paratranz翻译完后，我会将翻译后的文件放进“3-TranslatedParatranzFile”文件夹中，你检测其中所有文件，并且执行还原程序，将还原好的游戏文本输出到“4-SourceTranslatedFile”文件夹中。


***工作机制的具体描述：
在我双击“运行.bat”之后，输入1代表source2json，运行从原文件提取json的程序。输入2代表json2source，运行从json还原回原文件的程序。

1.待转换的游戏文本的不同类型
我将会把游戏文本的原文件放在“1-SourceFile”文件夹中，将会有如下的几种类型的文本，我会分别放在不同的子文件夹中，该文件夹中将会主要包含以下几个子文件夹：
①language文件夹：用于存放MC模组的语言文件，下含lang与json两个子文件夹。MC的语言文件分.lang格式与.json格式两种，在MC1.13以后，MC的语言文件从.lang格式改为了.json格式。
②txt文件夹：用于存放txt格式的文件，下含多个子文件夹用于存放来自不同模组的txt文件，但目前只有一个魔戒模组的LOTR子文件夹，下含lore文件夹（存放着魔戒模组的txt格式的书籍信函文件）、names文件夹（NPC姓名文件）和speech文件夹（魔戒NPC对话与小任务文件）。
③CustomNPCs文件夹：用于存放自定义NPC模组的对话与任务文件，下含两个子文件夹dialogs与quests，分别存放NPC对话文件与任务文件。
④BetterQuesting文件夹：用于存放“更好的任务”模组的文件
⑤“其他语言参考”文件夹：该文件夹内存放的是其他语言的翻译参考文件。例如我在俄译中项目中，可能俄文有看不懂的地方，就需要看一下被英文译者俄译英的译本，通过英文译本来理解俄文。而Paratranz没有“其他语言参考”这一功能，我只好把英文译本也转换成键值对格式来上传到Paratranz。该文件夹内会同时含有language、txt、CustomNPCs等所有的子文件夹与文件，只不过是另一种语言版的，里面的文件同样需要用对应的方式进行提取，我同样会将其上传至Paratranz。只不过只需执行提取程序不需要执行还原程序，因为我将其上传到Paratranz只是为了翻译参考。对于该文件夹你需要写一个判断，如果是提取模式则不跳过该文件夹，如果是还原模式则跳过该文件夹。



2.控制台报告信息输出
显示每个处理过的文件夹的统计信息，包括三级路径的显示、处理文件的数量：
格式为：“xx-xxx-xxx文件：已<提取/还原>完成，共<提取/还原>文件xxx个”

xxx-xxx-xxx是三级路径，固定取三级路径的文件夹名，并用“-”相连接，并作为一个统计单元。每处理完一个统计单元后，立即输出报告结果。
例如：“txt-LOTR-lore文件：已提取完成，共提取文件30个”
如果路径层级不足三级，则显示现有层级，若两级文件夹就没了，那就用两级。
例如：“language-lang文件：已提取完成，共提取文件1个”
而“其他语言参考文件”文件夹需要特殊处理，直接显示其名称而不是路径层级：“其他语言参考文件：已提取完成，共提取文件6000个”
而还原时也是一样，例如：
txt-LOTR-speech文件：已还原完成，共还原文件3000个

最后显示“总计处理文件：xxx个”

以及如果有文件没有提取出任何数据，检测到立马就警告，抛出报错信息：
“警告：txt/LOTR/lore/a dwarf.txt 未提取到有效内容”
“警告：CustomNPCs/dialogs/The Fellowship/6.json 未提取到有效内容”
文件名带着后缀并带着路径



3.提取与还原程序详细逻辑
提取：
在我输入1后，能够自动检测“1-SourceFile”文件夹中的所有文件（“1-SourceFile”文件夹在程序的上一级，程序位于Code文件夹），并支持检测多级文件结构，遍历扫描所有子文件夹，若某子文件夹不含任何文件则跳过。
扫描出来的文件需要根据不同文件类型来使用不同的模式来执行提取程序，具体什么类型的文件用什么模式，我会在后文描述。
提取后的文件的文件名保持原文件名与原后缀名不动，直接在原后缀名末尾再加一个.json，并输出到“2-ConvertedParatranzFile”文件夹中，但是输出前需要先删除“2-ConvertedParatranzFile”文件夹中的原有内容，避免旧文件残留。

还原：
我会将你提取出来的文件上传至Paratranz翻译，并将翻译后的文件下载至“3-TranslatedParatranzFile”文件夹，我下载的这些文件的路径结构会依然与“1-SourceFile”中的相同。
然后我会输入2，于是你就需要把“3-TranslatedParatranzFile”文件夹中的文件还原回初始格式，也就是按照键名的路径信息，用值中的文本替换“1-SourceFile”中的原文件中的原文，并输出至“4-SourceTranslatedFile”文件夹，但是输出前需要先删除“4-SourceTranslatedFile”文件夹中的原有内容，避免旧文件残留。
并且输出的文件的文件名就是把“3-TranslatedParatranzFile”文件夹中文件最后的.json后缀删掉，剩下的文本就是原文件名与原后缀名了。
你需要根据不同文件类型来使用不同的模式来执行还原程序，具体什么类型的文件用什么模式，我会在后文描述。
如果有文件并不是经过本程序提取而生成的，例如1-SourceFile/language/json里的语言文件，则不需要为其还原格式。
“其他语言参考”文件夹不需要执行还原程序，在还原过程中忽略该文件夹，因为只是作为翻译参考而不会在游戏中应用。



4.针对不同文件的提取与还原的不同模式
根据文件类型自动选择模式来提取文本，将文本提取为键值对.json文件，并输出到“2-ConvertedParatranzFile”文件夹中。
以下是针对上面所说的种类，而设计的提取模式（每种模式之间互不干扰，若某文件没提使用什么模式则可不进行处理）：

①lang语言文件：
位于lang文件夹中，.lang文件的格式很简单，它用“=”等于号来连接代码名与文本，你只需要将左边的代码名与右边的文本分别转换成json键值对的键与值即可。（1-SourceFile/language/json文件夹中的json文件直接就符合Paratranz的要求，不需要对其操作，直接输出到3-TranslatedParatranzFile文件夹）
但注意，lang文件中可能会有用#的注释和空行，你不可跳过，将注释与空行也写进键值对。在程序开始前，先准备对注释与空行的计数，将次数作为编号。注释连带着“#”都写进值中，而键为comment_line.<编号>。空行的值为\n，而键为blank_line.<编号>。
例如在769行的注释是第5次出现，那键名就是comment_line.5；如果在1125行的空行是第32次出现，那键名就是blank_line.32

而还原的时候要反向处理，首先解析json文件，先将所有的键值对包括空行与注释的，全都转换为lang文件的“=”格式。
就比如注释就转换成comment_line.123=#物品栏，空行就转换为blank_line.234=\n，其他的键值对也都反向处理。
然后开始逐行检测，直接用正则表达式检测，不要你先按编号排序，不要最后才把空行和注释插入。要直接逐行检测，写一个判断程序，检测到如果“=”的左边是“comment_line.<数字>”就把当前行“=”后面的留下，等于号以及等于号前面的都删掉；如果检测到是“blank_line.<数字>”，那么就直接将本行整行都替换为换行，也就是一个空行。
你不需要检测空行与注释的行号或者编号，行号与编号只是为了区分不同键名。更不需要按照编号给他们排序。你只需要在每行检测“=”的左边是否是“comment_line.<数字>”就行了，就这么简单，不要复杂化。
下面是lang文件原文件的示例：
“
#创造模式物品栏
itemGroup.tabBloodMagic=血魔法

#其他文本
bm.string.consume=使用
bm.string.drain=消耗
”


②魔戒lore文件：
位于1-SourceFile/txt/LOTR/lore文件夹中，这里面每一个文件都是一本魔戒模组的书籍与信函。每个文件要单独一个键值对，键为“lotr.lore.<文件名>”，值为文件内的完整所有内容。lore文件夹中的所有文件都提取进同一个json文件中，每一行键值对就对应一个lore的文件。
lore文件会有多行甚至空行，你需要把所有的换行都转换为\n。在还原时再反向处理还原回正常的换行。
还原时，需要反向处理还原回原文件的格式，并变为.txt文件。
下面是lore文件的示例：
“
#Formatting Test
#
#title:Тяжелая работа
#author:{name:dwarf_male}
#types:durins_folk
#
Сегодня я выпил {num:5,10} кружек эля.

Я копался с {name:dwarf_male} в шахтах, и мы работали сменами по {num:1,6} часа, как должен каждый гном!

Затем я отправился домой к моей дорогой жене, {имя: dwarf_female}, и дочке, {name: dwarf_female}. После ужина мы спели старые рассказы о Дурине и Кхазад-думе.
”
提取后即为"lotr.lore.a dwarf": "#Formatting Test\n#\n#title:Тяжелая работа\n#author:{name:dwarf_male}\n#types:durins_folk\n#\nСегодня я выпил {num:5,10} кружек эля.\n\nЯ копался с {name:dwarf_male} в шахтах, и мы работали сменами по {num:1,6} часа, как должен каждый гном!\n\nЗатем я отправился домой к моей дорогой жене, {имя: dwarf_female}, и дочке, {name: dwarf_female}. После ужина мы спели старые рассказы о Дурине и Кхазад-думе."
单个lore文件中的所有内容都要完整的提取进一个值中，如果遇到会破坏json语法结构的特殊符号，则在前添加转义符号。


③speech与names文件：
speech与names文件的段落格式相同，因此可以放在一起处理。它们位于1-SourceFile里的txt/LOTR/speech文件夹与txt/LOTR/names文件夹中，这些文件是魔戒模组NPC的对话与姓名，包含多级目录众多子文件夹，需要遍历检测每个子文件夹，输出的时候也要输出多级文件结构，要保留原来的文件结构。
每个文件中都会有一行一行的文本，每一行文本都要单独写进一个值，而键名则是lotr.speech(或者names).<一级子文件夹名>.<二级三级等文件夹名>.<文件名>.<行数>。
例如“1-SourceFile/txt/LOTR/speech/anduin/beorning/bartender/friendly.txt”文件中的第四行文本，其键名就是“lotr.speech.anduin.beorning.bartender.friendly.4”。
这些文件无需考虑注释与空行，因为不会出现注释与空行。
而还原时，需要反向处理还原回原文件的格式，也就是每行都只保留值，其他的都删掉。并且也要保留原来的多级文件结构。


④CustomNPCs文件：
位于1-SourceFile下面的CustomNPCs文件夹里，下含dialogs和quests两个文件夹分别存放自定义NPC的对话和任务。
不管是下含的dialogs文件夹还是quests文件夹的文件，都使用同样的提取逻辑。
读取文件时，可能需要将整个文件内容读入一个字符串，这样正则表达式才能跨行匹配。并且使用非贪婪匹配尽快匹配到最近的结束标记。
要检测的数据的类型分为以下几种：
- DialogText：这是与NPC对话时，NPC说的话。
- Title：这是与NPC对话时，玩家可以选择的回答选项，一个对话会有多个选项。
- Text：任务介绍文本。
- CompleteText：任务完成文本。

DialogText、Text或CompleteText这几类数据，将整个文件中读入一个字符串中检测，DialogText类数据从“"DialogText": "”后面开始提取，到“",”前面结束。而Text类数据就是从“"Text": "”后面开始提取，到“",”前面结束。以此类推。
中间可能经历多行，会有换行符，提取结束后，需要将提取的数据中的换行转换为\n换行符，这样才能将多行数据变为一行写进值中。
键名是“customnpcs.<多级文件夹名>.file<文件名>.<原字符串名>”
例如1-SourceFile/customnpcs/quests/The Way of the Hobbit/29.json这个文件，其CompleteText的键名就是“customnpcs.quests.The Way of the Hobbit.file29.CompleteText”

而Title类数据的处理比较特殊，需要先在文件中检测是否存在“OptionSlot”字符串，若该文件中没有“OptionSlot”字符串，则不提取Title数据。
将整个文件中读入一个字符串中检测，一个文件中可能存在多个Title数据，应找到所有匹配项。
从“"Title": "”后面开始提取，到“",”前面结束。
开始检测后，开始计数，每检测出一个Title数据则计一个数，作为该Title的编号。
键名是“customnpcs.<多级文件夹名>.file<文件名>.Title.slot<编号>”
例如1-SourceFile/customnpcs/dialogs/The Fellowship/4.json这个文件，当检测到第三个Title数据的时候，其键名则为“dialogs.The Fellowship.file4.Title.slot3”

还原时需要按照键名中的路径信息，找到对应的原文件，反向处理，将翻译后的数据替换进原文件对应位置，然后将所有的\n转换为成换行，最后将文件输出到“4-SourceTranslatedFile”文件夹。
对于Title类数据的还原，要先创建列表进行编号，然后按照编号一一替换还原，不要将所有的Title替换成同一个数据。
